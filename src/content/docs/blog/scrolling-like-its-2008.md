---
title:  "Scrolling like it's 2008"
date: 2024-04-23
tags:
- mobile-performance
- scrolling
- swiftui
- jetpack-compose
- cross-platform
- flutter
- react-native
- skip
- ui-frameworks
- animation-jank
layout: post
permalink: /blog/scrolling-like-its-2008/
author: Marc Prud'hommeaux
---

Back in 2008 when Abe and I were working on our first iPhone app *Stanza*, there was a very influential blog post by Loren Brichter, the developer of a popular Twitter client app (back when such things were not only permitted, but *encouraged*), titled: ”Fast Scrolling in Tweetie[^1]”, which opened with:

> Scrolling is the primary method of interaction on the iPhone. It has to be fast. It ***has to*** be fast. 

This is as true in 2024 as it was in 2008. Which makes it all the more surprising that people are still shipping apps that exhibit scrolling issues. Animation jank, muddy inertia, and dropped frames are among the most common issues that plague applications that were built with frameworks that eschew the platform-native list controls and decide to re-invent the wheel. Scrolling is one of the most commonly cited examples of these apps feeling to users like they are in the "uncanny valley" – that oft-indescribable sense that an app feels *not quite right*.

### From UIKit to SwiftUI

Back in 2008, making a high-performance list control for iOS could be quite an involved chore. Anyone who recalls fighting with UIKit's `UITableView` and all its warts will remember with a shudder just how persnickety the control could be, and how painful coordinating the mess of Objective-C data sources and delegates would invariably become.

Thankfully, the emergence of SwiftUI in 2019 meant that creating a buttery-smooth list control with thousands of elements is as simple as 5 lines:

```swift
List {
    ForEach(1..<1_000) { i in
        NavigationLink("Item \(i)", value: i)
    }
}
```

<div style="display: flex; justify-content: flex-end; gap: 2em; XXalign-items: center;">

<div style="flex: 70%;">
This example is lifted directly out of the project generated by <code>skip init</code>, as shown in the <a href="/docs/gettingstarted">getting started</a> guide. Run this on your iPhone and fling-scroll the list to your heart's content: never a stutter or pause to be found, and the physics of the interaction feel perfectly correct for the device. This is because SwiftUI's <code>List</code> doesn't re-invent the underlying UIKit list components, but rather it manages them for you. All the complexity and error-prone bookkeeping of the underlying UIKit controls are automatically taken care of.
</div>
  
<div style="flex: 30%;">
<video id="scrolling-ios" autoplay muted loop>
  <source src="https://assets.skip.dev/videos/scrolling-like-2008-ios.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>
</div>

</div>

### From Views to Jetpack Compose

On the Android side, the equivalent Jetpack Compose list control is a `LazyColumn`. Compose names are different from SwiftUI, but the effect is the same – you can create a silky-smooth list control with just this 5-line snippet:

```kotlin
LazyColumn {
    items(List(1000) { it }) { item ->
        Text(text = "Item ${item}")
    }
}
```

<div style="display: flex; justify-content: flex-end; gap: 2em; XXalign-items: center;">

<div style="flex: 70%;">

And in the same way as SwiftUI's <code>List</code> wraps and manages the underlying UIKit family of Objective-C classes, Compose's Kotlin <code>LazyColumn</code> sidesteps having to use the Java <code>RecyclerView</code> and <code>LinearLayoutManager</code> classes from the older Android SDK and manages all the complexity of displaying a high-performance list of items. When coming from the old-school imperative APIs, creating user interfaces with the modern declarative style is a breath of fresh air.
</div>
  
<div style="flex: 30%;">
<video id="scrolling-android" autoplay muted loop>
  <source src="https://assets.skip.dev/videos/scrolling-like-2008-android.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>
</div>

</div>

### The Framework Tax

The fact that these vendor-supported toolkits – SwiftUI and Compose – are built atop the platform-native scrolling mechanics stands in contrast with some of the other cross-platform frameworks created in "alien" languages like Dart and JavaScript, that instead attempt to implement all this complexity on their own.

Back in 2012, Benjamin Sandofsky wrote about "The Framework Tax[^2]":

> For native apps, performance is critical to a great user experience. Users notice jerky scrolling, and performance can make or break a feature

Back then, the popular solutions purporting to simplify cross-platform app development were simple WebView-based wrappers designed to make JavaScript and HTML look and feel like a real app. These particular attempts have fallen out of fashion and have been replaced by newer offerings like Flutter, React Native, and Xamarin that use Dart, JavaScript, and C# (respectively) to attempt to abstract away the platform-native frameworks and provide their own homogeneous API for developers to create their apps with.

But what hasn't changed is that each of these attempts still adds a layer of indirection and overhead to the app, as has been analyzed and confirmed by academic research[^3]. They all require writing your app in a separate language and IDE, and then bundling the distributed app with a separate garbage-collected runtime layer, as well as often including a graphics engine that performs the low-level drawing. All of these frameworks introduce overhead: battery-killing inefficiencies[^4], pauses from garbage-collection, animation jank from the graphics technology[^5], or friction resulting from bridging between an alien language and the platform's native language. For an overview of these issues, see our [Skip comparison page](/compare).

### The Skip Difference

And that's the difference with Skip: when you create your app using Skip, you are coding directly to Apple's SwiftUI – *in Swift* – on iOS, and transpiling directly Google's Jetpack Compose – *in Kotlin* – on Android. These are the official, vendor-recommended languages and toolkits for creating modern apps. They are as fast as they can conceivably be, and they will continue to be supported by the platform vendors in perpetuity. By transpiling your Swift into Kotlin, Skip avoids the overhead of abstracting the platform from an alien language, but instead embraces each platforms's strengths and performance potential.

That's why we are convinced that Skip is the right approach for creating mobile apps while still retaining the benefit of a single codebase. Quite simply, it enables your app to be the uncompromisingly best experience it can possibly be. So go ahead: scroll like it's 2008, when the mobile world was new, apps were fast, and Tweetie was all the rage!



<!-- , including the recycling pre-existing row views to reduce allocations (critical to staying within the 16 millisecond-per-frame budget necessary for a 60fps scrolling experience). -->

<!-- Pervasive animation jank and dropped frames finally compelled the Flutter team to toss the Skia rendering engine and write a whole new "Impeller" engine last year. Similarly, Meta ditched JavaScriptCore and wrote a whole new JavaScript engine, "Hermes", to try to improve the experience of React Native apps. And Microsoft discontinued Xamarin altogether, with the hopes that their nascent "MAUI" framework will eventually become a suitable replacement. -->

<!-- Such rewrites and reimplementations would never have happened if these frameworks were providing a satisfactory experience for developers and users. That fact that they were deemed necesary speaks an obvious truth: trying to re-invent the platform-native user experience is doomed to failure. Whether the issue is performance, memory usage, "uncanny valley" look and feel, inability to keep up with changing platform conventions, or – most frequently – as combination of all these factors. -->

#### Addendum

After writing this, Abe informed me that not only did he, while at Twitter, architect the transition from Loren Brichter’s CoreGraphics-based drawing to UIKit Views in the Twitter app, but he also happened to be working with Benjamin Sandofsky at the time as well. I had no idea. Small world!
{: style="font-size: 0.8em;"}

[^1]: Archive of “Fast Scrolling in Tweetie”: [https://web.archive.org/web/20111201182613/http://blog.atebits.com/2008/12/fast-scrolling-in-tweetie-with-uitableview](https://web.archive.org/web/20111201182613/http://blog.atebits.com/2008/12/fast-scrolling-in-tweetie-with-uitableview)
[^2]: "Shell Apps and Silver Bullets" by Benjamin Sandofsky: [https://www.sandofsky.com/cross-platform/](https://www.sandofsky.com/cross-platform/)
[^3]: Jozef Goetz and Yan Li. “Evaluation of Cross-Platform Frameworks for Mobile Applications.” In: International Conference on Engineering and Applied Science [https://www.researchgate.net/publication/327719390_Evaluation_of_Cross-Platform_Frameworks_for_Mobile_Applications](https://www.researchgate.net/publication/327719390_Evaluation_of_Cross-Platform_Frameworks_for_Mobile_Applications)
[^4]: Thomas Dorfer, Lukas Demetz, and Stefan Huber. “Impact of mobile cross-platform development on CPU, memory and battery of mobile devices when using common mobile app features.” [https://www.sciencedirect.com/science/article/pii/S1877050920317099](https://www.sciencedirect.com/science/article/pii/S1877050920317099)
[^5]: Damian Białkowski and Jakub Smołka. “Evaluation of Flutter framework time efficiency in context of user interface tasks.” In: Journal of Computer Sciences Institute 25 [https://ph.pollub.pl/index.php/jcsi/article/view/3007](https://ph.pollub.pl/index.php/jcsi/article/view/3007)


<!-- [^4]: Performance analysis of SwiftUI and UIKit: [https://kth.diva-portal.org/smash/get/diva2:1789094/FULLTEXT01.pdf](https://kth.diva-portal.org/smash/get/diva2:1789094/FULLTEXT01.pdf) -->

